<!DOCTYPE html>
<html lang="en-us">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="HotSpot JVM: Thread-Local Allocation Buffers">
<meta itemprop="description" content="Introduction Applications developed in managed languages running on top of a virtual-machine like the JVM or the CLR tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&rsquo;s heap.
Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen."><meta itemprop="datePublished" content="2021-09-20T00:00:00+00:00" />
<meta itemprop="dateModified" content="2021-09-20T00:00:00+00:00" />
<meta itemprop="wordCount" content="1495">
<meta itemprop="keywords" content="garbage-collection,algorithms,virtual-machines,hotspot," /><meta property="og:title" content="HotSpot JVM: Thread-Local Allocation Buffers" />
<meta property="og:description" content="Introduction Applications developed in managed languages running on top of a virtual-machine like the JVM or the CLR tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&rsquo;s heap.
Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jorgedfbranco.github.io/posts/hotspot-jvm-thread-local-allocation-buffers/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2021-09-20T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="HotSpot JVM: Thread-Local Allocation Buffers"/>
<meta name="twitter:description" content="Introduction Applications developed in managed languages running on top of a virtual-machine like the JVM or the CLR tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&rsquo;s heap.
Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>HotSpot JVM: Thread-Local Allocation Buffers</title>
	<link rel="stylesheet" href="https://jorgedfbranco.github.io/css/style.min.5425597751a427b0726de11f911921f1a4d38dd73b481894167d2cf91f77780e.css" integrity="sha256-VCVZd1GkJ7BybeEfkRkh8aTTjdc7SBiUFn0s+R93eA4=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a style="font-weight: 400;" href="https://jorgedfbranco.github.io">Jorge Branco&#39;s Blog</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="https://github.com/jorgedfbranco" target="_blank" rel="noopener me" title="Github"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a><a href="https://linkedin.com/in/jorgedfbranco" target="_blank" rel="noopener me" title="Linkedin"><svg xmlns="http://www.w3.org/2000/svg" class="feather" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
		</ul>
	</div>


	<main class="site-main section-inner animated fadeIn faster">
		<article class="thin">
			<header class="post-header">
				<div class="post-meta"><span>Sep 20, 2021</span></div>
				<h1>HotSpot JVM: Thread-Local Allocation Buffers</h1>
			</header>
			<div class="content">
				<h2 id="introduction">Introduction<a href="#introduction" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>Applications developed in managed languages running on top of a virtual-machine like the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> or the <a href="https://en.wikipedia.org/wiki/Common_Language_Runtime">CLR</a> tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&rsquo;s heap.</p>
<p>Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen. Wrapping the allocation function with a lock will make sure the allocation logic is correct but will induce serious performance degradation &ndash; the higher the number of threads and quantity of allocation requests per unit of time, the higher the pressure on the lock and the slower requests will end up served.</p>
<p>To minimize the problem, most modern VMs will in a way or another use the concept of a <code>thread-local allocation buffer</code> (TLAB). Instead of having threads perform hundreds of requests per second to the heap, it&rsquo;s preferable to have them request huge chunk of memory from time to time. They can then in a thread-local, unsynchronized way allocate all objects from that local chunk (buffer) at very high speeds. Only when that buffer runs out of available memory shall the thread make another request to the heap.</p>
<h2 id="hotspot">HotSpot<a href="#hotspot" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>The aim of this article is to investigate how TLABs are implemented on the HotSpot VM and go over a couple of their most commmon use-cases:</p>
<ol>
<li>How and when are they initialized? To what size?</li>
<li>How is memory allocated from them, namely, when creating an object?</li>
<li>How are they refilled when running out of available memory?</li>
<li>How are they dealt with when a thread dies?</li>
</ol>
<p>For that we&rsquo;ll go over HotSpot&rsquo;s <code>Thread</code> and <code>ThreadLocalAllocBuffer</code> classes, where TLAB&rsquo;s core logic resides.</p>
<h3 id="thread-implementation">Thread Implementation<a href="#thread-implementation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<p>The base thread definition / implementation in HotSpot is at <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.hpp">thread.hpp</a> / <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp">thread.cpp</a>. It&rsquo;s quite a fat class but we&rsquo;ll keep it simple by only looking at TLAB-related fields / methods:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Thread</span><span class="o">:</span> <span class="k">public</span> <span class="n">ThreadShadow</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">ThreadLocalAllocBuffer</span> <span class="n">_tlab</span><span class="p">;</span>                 <span class="c1">// Thread-local eden
</span><span class="c1"></span>    <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// Thread-Local Allocation Buffer (TLAB) support
</span><span class="c1"></span>        <span class="n">ThreadLocalAllocBuffer</span><span class="o">&amp;</span> <span class="n">tlab</span><span class="p">()</span>                 <span class="p">{</span> <span class="k">return</span> <span class="n">_tlab</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">initialize_tlab</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.hpp#L132">thread.hpp:132</a></p>
</span>
</div>
<p>When the <code>Thread</code> class is first created, an un-initialized TLAB structure is inlined in the <code>Thread</code> object. But it will only get initialized the moment a call to <code>JavaThread::run()</code> is performed:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// The main routine called by a new Java thread. This isn&#39;t overridden
</span><span class="c1">// by subclasses, instead different subclasses define a different &#34;entry_point&#34;
</span><span class="c1">// which defines the actual logic for that kind of thread.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">JavaThread</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// initialize thread-local alloc buffer related fields
</span><span class="c1"></span>    <span class="n">initialize_tlab</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L1229">thread.cpp:1229</a></p>
</span>
</div>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Thread</span><span class="o">::</span><span class="n">initialize_tlab</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UseTLAB</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tlab</span><span class="p">().</span><span class="n">initialize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L284">thread.cpp:284</a></p>
</span>
</div>
<p>And, as expected, the moment the thread is killed, the TLAB is also destroyed (retired):</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">JavaThread</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="kt">bool</span> <span class="n">destroy_vm</span><span class="p">,</span> <span class="n">ExitType</span> <span class="n">exit_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UseTLAB</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tlab</span><span class="p">().</span><span class="n">retire</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L1320">thread.cpp:1320</a></p>
</span>
</div>
<p>To know what <code>tlab().initialize()</code> and <code>tlab().retire()</code> actually do, we&rsquo;ll now need to delve into the TLAB object, <code>ThreadLocalAllocBuffer</code>:</p>
<h3 id="tlab-implementation">TLAB Implementation<a href="#tlab-implementation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>
<h4 id="class-definition">Class Definition<a href="#class-definition" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>A TLAB is represented in HotSpot by the <code>ThreadLocalAllocBuffer</code> class:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">ThreadLocalAllocBuffer</span><span class="o">:</span> <span class="k">public</span> <span class="n">CHeapObj</span><span class="o">&lt;</span><span class="n">mtThread</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_start</span><span class="p">;</span>                              <span class="c1">// address of TLAB
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_top</span><span class="p">;</span>                                <span class="c1">// address after last allocation
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_pf_top</span><span class="p">;</span>                             <span class="c1">// allocation prefetch watermark
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_end</span><span class="p">;</span>                                <span class="c1">// allocation end (can be the sampling end point or _allocation_end)
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_allocation_end</span><span class="p">;</span>                     <span class="c1">// end for allocations (actual TLAB end, excluding alignment_reserve)
</span><span class="c1"></span>
    <span class="n">size_t</span>    <span class="n">_desired_size</span><span class="p">;</span>                       <span class="c1">// desired size   (including alignment_reserve)
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_refill_waste_limit</span><span class="p">;</span>                 <span class="c1">// hold onto tlab if free() is larger than this
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_allocated_before_last_gc</span><span class="p">;</span>           <span class="c1">// total bytes allocated up until the last gc
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_bytes_since_last_sample_point</span><span class="p">;</span>      <span class="c1">// bytes since last sample point.
</span><span class="c1"></span>
    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp#L46">threadLocalAllocBuffer.hpp:46</a></p>
</span>
</div>
<p>from which the most important fields are:</p>
<ul>
<li><code>_start</code> - a pointer to the starting address of this TLAB;</li>
<li><code>_top</code> - a pointer to the address of the last allocation, or equivalently, where the next object is going to be allocated on this TLAB;</li>
<li><code>_end</code> - a pointer to the end of this TLAB.</li>
</ul>
<p>As we&rsquo;re going to see in the next section, allocations on a TLAB should be a relatively inexpensive operation:</p>
<h4 id="allocation">Allocation<a href="#allocation" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Allocation happens in a relatively straightforward way: as long as there&rsquo;s enough space in the TLAB, allocating <code>size</code> amount of memory out of a TLAB can be as simple as bumping up <code>_top</code> by <code>size</code>:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kr">inline</span> <span class="n">HeapWord</span><span class="o">*</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">HeapWord</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">top</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pointer_delta</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set_top</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp#L38">threadLocalAllocBuffer.inline.hpp:38</a></p>
</span>
</div>
<p>In the bytecode interpreter, for instance, when an allocation request comes in, here&rsquo;s how <code>ThreadLocalAllocBuffer::allocate()</code> ends up invoked:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">BytecodeInterpreter</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">interpreterState</span> <span class="n">istate</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">CASE</span><span class="p">(</span><span class="n">_new</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
            <span class="p">...</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ik</span><span class="o">-&gt;</span><span class="n">is_initialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ik</span><span class="o">-&gt;</span><span class="n">can_be_fastpath_allocated</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">size_t</span> <span class="n">obj_size</span> <span class="o">=</span> <span class="n">ik</span><span class="o">-&gt;</span><span class="n">size_helper</span><span class="p">();</span>
                <span class="n">HeapWord</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">THREAD</span><span class="o">-&gt;</span><span class="n">tlab</span><span class="p">().</span><span class="n">allocate</span><span class="p">(</span><span class="n">obj_size</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">oop</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">cast_to_oop</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

                    <span class="c1">// Initialize header
</span><span class="c1"></span>                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_mark</span><span class="p">(</span><span class="n">markWord</span><span class="o">::</span><span class="n">prototype</span><span class="p">());</span>
                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_klass_gap</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_klass</span><span class="p">(</span><span class="n">ik</span><span class="p">);</span>

                    <span class="c1">// Must prevent reordering of stores for object initialization
</span><span class="c1"></span>                    <span class="c1">// with stores that publish the new object.
</span><span class="c1"></span>                    <span class="n">OrderAccess</span><span class="o">::</span><span class="n">storestore</span><span class="p">();</span>
                    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp#L405">bytecodeInterpreter.cpp:405</a></p>
</span>
</div>
<p>otherwise, a slower and costlier path is followed that ends up performing direct allocations on the Heap itself:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Slow case allocation
</span><span class="c1"></span><span class="n">CALL_VM</span><span class="p">(</span><span class="n">InterpreterRuntime</span><span class="o">::</span><span class="n">_new</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">METHOD</span><span class="o">-&gt;</span><span class="n">constants</span><span class="p">(),</span> <span class="n">index</span><span class="p">),</span> <span class="n">handle_exception</span><span class="p">);</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp#L1870">bytecodeInterpreter.cpp:1870</a></p>
</span>
</div>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">JRT_ENTRY</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">InterpreterRuntime</span><span class="o">::</span><span class="n">_new</span><span class="p">(</span><span class="n">JavaThread</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span> <span class="n">ConstantPool</span><span class="o">*</span> <span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">))</span>
    <span class="n">Klass</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">klass_at</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">CHECK</span><span class="p">);</span>
    <span class="n">InstanceKlass</span><span class="o">*</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">InstanceKlass</span><span class="o">::</span><span class="n">cast</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="n">oop</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">klass</span><span class="o">-&gt;</span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">CHECK</span><span class="p">);</span>
    <span class="p">...</span>
<span class="n">JRT_END</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/interpreterRuntime.cpp#L217">interpreterRuntime.cpp:217</a></p>
</span>
</div>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">instanceOop</span> <span class="n">InstanceKlass</span><span class="o">::</span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">size_helper</span><span class="p">();</span>

    <span class="p">...</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">instanceOop</span><span class="p">)</span><span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">obj_allocate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">CHECK_NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/oops/instanceKlass.cpp#L1413">instanceKlass.cpp:1413</a></p>
</span>
</div>
<h4 id="vm-parameters">VM Parameters<a href="#vm-parameters" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>All the VM parameters related to TLABs, such as <code>UseTLAB</code>, <code>ResizeTLAB</code>, <code>ZeroTLAB</code>, <code>MinTLABSize</code>, <code>TLABSize</code>, may be found at <code>tlab_globals.cpp</code>:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="p">...</span>
    <span class="cm">/* Thread Local Allocation Buffer */</span>                                      \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">UseTLAB</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                              \
            <span class="s">&#34;Use thread-local object allocation&#34;</span><span class="p">)</span>                             \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ResizeTLAB</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                           \
            <span class="s">&#34;Dynamically resize TLAB size for threads&#34;</span><span class="p">)</span>                       \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ZeroTLAB</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>                                            \
            <span class="s">&#34;Zero out the newly created TLAB&#34;</span><span class="p">)</span>                                \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">TLABStats</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                            \
            <span class="s">&#34;Provide more detailed and expensive TLAB statistics.&#34;</span><span class="p">)</span>           \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">MinTLABSize</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">K</span><span class="p">,</span>                                         \
            <span class="s">&#34;Minimum allowed TLAB size (in bytes)&#34;</span><span class="p">)</span>                           \
            <span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_uintx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>                                             \
            <span class="n">constraint</span><span class="p">(</span><span class="n">MinTLABSizeConstraintFunc</span><span class="p">,</span><span class="n">AfterMemoryInit</span><span class="p">)</span>             \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">TLABSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                              \
            <span class="s">&#34;Starting TLAB size (in bytes); zero means set ergonomically&#34;</span><span class="p">)</span>    \
            <span class="n">constraint</span><span class="p">(</span><span class="n">TLABSizeConstraintFunc</span><span class="p">,</span><span class="n">AfterMemoryInit</span><span class="p">)</span>                \
    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/tlab_globals.hpp#L38">tlab_globals.hpp:38</a></p>
</span>
</div>
<h4 id="initialization-and-refill">Initialization and Refill<a href="#initialization-and-refill" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>The allocation of the region of memory used by a TLAB is, and maybe surprisingly, always external to this class. It&rsquo;s always up to the caller of <code>ThreadLocalAllocBuffer</code> to correctly allocate a memory region <code>R</code> and call <code>ThreadLocalAllocBuffer::fill(start, top, new_size)</code> to make the TLAB be aware of, and use, <code>R</code>.</p>
<p>In pratical terms, the first time a memory region is associated with a TLAB is when a thread&rsquo;s first allocation request comes in and fails:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">HeapWord</span><span class="o">*</span> <span class="n">MemAllocator</span><span class="o">::</span><span class="n">allocate_inside_tlab</span><span class="p">(</span><span class="n">Allocation</span><span class="o">&amp;</span> <span class="n">allocation</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// Try allocating from an existing TLAB.
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">-&gt;</span><span class="n">tlab</span><span class="p">().</span><span class="n">allocate</span><span class="p">(</span><span class="n">_word_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Try refilling the TLAB and allocating the object in it.
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">allocate_inside_tlab_slow</span><span class="p">(</span><span class="n">allocation</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">HeapWord</span><span class="o">*</span> <span class="n">MemAllocator</span><span class="o">::</span><span class="n">allocate_inside_tlab_slow</span><span class="p">(</span><span class="n">Allocation</span><span class="o">&amp;</span> <span class="n">allocation</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">size_t</span> <span class="n">min_tlab_size</span> <span class="o">=</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">compute_min_size</span><span class="p">(</span><span class="n">_word_size</span><span class="p">);</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">allocate_new_tlab</span><span class="p">(</span><span class="n">min_tlab_size</span><span class="p">,</span> <span class="n">new_tlab_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allocation</span><span class="p">.</span><span class="n">_allocated_tlab_size</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">tlab</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">_word_size</span><span class="p">,</span> <span class="n">allocation</span><span class="p">.</span><span class="n">_allocated_tlab_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/memAllocator.cpp#L268">memAllocator.cpp:268</a></p>
</span>
</div>
<p>This is, of course, the very same code-path that&rsquo;s executed when, after a sequence of allocations, the TLAB gets full and a new allocation from the heap is needed to refill it.</p>
<h4 id="sizing">Sizing<a href="#sizing" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>The TLAB size can be hard-coded and passed as a JVM parameter (<code>TLABSize</code>), or calculated on-the-fly:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">size_t</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">initial_desired_size</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">init_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TLABSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init_sz</span> <span class="o">=</span> <span class="n">TLABSize</span> <span class="o">/</span> <span class="n">HeapWordSize</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Initial size is a function of the average number of allocating threads.
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nof_threads</span> <span class="o">=</span> <span class="n">ThreadLocalAllocStats</span><span class="o">::</span><span class="n">allocating_threads_avg</span><span class="p">();</span>

    <span class="n">init_sz</span>  <span class="o">=</span> <span class="p">(</span><span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">tlab_capacity</span><span class="p">(</span><span class="kr">thread</span><span class="p">())</span> <span class="o">/</span> <span class="n">HeapWordSize</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nof_threads</span> <span class="o">*</span> <span class="n">target_refills</span><span class="p">());</span>
    <span class="n">init_sz</span> <span class="o">=</span> <span class="n">align_object_size</span><span class="p">(</span><span class="n">init_sz</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">init_sz</span> <span class="o">=</span> <span class="n">MIN2</span><span class="p">(</span><span class="n">MAX2</span><span class="p">(</span><span class="n">init_sz</span><span class="p">,</span> <span class="n">min_size</span><span class="p">()),</span> <span class="n">max_size</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">init_sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L268">threadLocalAllocBuffer.cpp:268</a></p>
</span>
</div>
<h4 id="death">Death<a href="#death" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h4>
<p>Finally, what happens when a thread is about do die? It turns out that whatever space is still unused will be used to allocate a dummy integer array:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">retire</span><span class="p">(</span><span class="n">ThreadLocalAllocStats</span><span class="o">*</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">thread</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incr_allocated_bytes</span><span class="p">(</span><span class="n">used_bytes</span><span class="p">());</span>
      <span class="n">insert_filler</span><span class="p">();</span>
      <span class="n">initialize</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L137">threadLocalAllocBuffer.cpp:137</a></p>
</span>
</div>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">insert_filler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">hard_end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">fill_with_dummy_object</span><span class="p">(</span><span class="n">top</span><span class="p">(),</span> <span class="n">hard_end</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L119">threadLocalAllocBuffer.cpp:119</a></p>
</span>
</div>
<p><code>CollectedHeap::fill_with_dummy_object()</code> will, after a sequence of calls end up at:</p>
<div style="background: linear-gradient(90deg, rgba(73,79,92,1) 60%, rgba(44,62,80,1) 80%);">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">CollectedHeap</span><span class="o">::</span><span class="n">fill_with_array</span><span class="p">(</span><span class="n">HeapWord</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">words</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zap</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">const</span> <span class="n">size_t</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="n">words</span> <span class="o">-</span> <span class="n">filler_array_hdr_size</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">payload_size</span> <span class="o">*</span> <span class="n">HeapWordSize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jint</span><span class="p">);</span>

    <span class="n">ObjArrayAllocator</span> <span class="nf">allocator</span><span class="p">(</span><span class="n">Universe</span><span class="o">::</span><span class="n">intArrayKlassObj</span><span class="p">(),</span> <span class="n">words</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">,</span> <span class="cm">/* do_zero */</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/collectedHeap.cpp#L425">collectedHeap.cpp:425</a></p>
</span>
</div>
<h2 id="conclusion">Conclusion<a href="#conclusion" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<p>We covered a simplified view of how TLABs work in HotSpot, and this should be more than enough to get one going if wanting to dive deeper. Be aware that not all GCs will use <code>ThreadLocalAllocBuffer</code>. The ZGC collector, for instance, will use its own implementation of a TLAB through its <code>ZThreadLocalAllocBuffer</code> class.</p>
<h2 id="references">References<a href="#references" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h2>
<ul>
<li><a href="https://alidg.me/blog/2019/6/21/tlab-jvm">Thread-Local Allocation Buffers in JVM</a></li>
<li><a href="https://shipilev.net/jvm/anatomy-quarks/4-tlab-allocation/">JVM Anatomy Quark #4: TLAB allocation</a></li>
<li><a href="https://programmerclick.com/article/3946498271/">Análisis de código fuente JVM G1 - asignación de espacio de montón para objetos</a></li>
<li><a href="https://programmer.ink/think/thread-local-cache-tlab-for-jvm-source-analysis.html">Thread Local Cache TLAB for JVM Source Analysis</a></li>
</ul>

			</div>
			<hr class="post-end">
			<footer class="post-info">
				<p>
					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://jorgedfbranco.github.io/tags/garbage-collection">garbage-collection</a></span><span class="tag"><a href="https://jorgedfbranco.github.io/tags/algorithms">algorithms</a></span><span class="tag"><a href="https://jorgedfbranco.github.io/tags/virtual-machines">virtual-machines</a></span><span class="tag"><a href="https://jorgedfbranco.github.io/tags/hotspot">hotspot</a></span>
				</p>
				<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>1495 Words</p>

			</footer>
		</article>
		<div class="post-nav thin">
			<a class="prev-post" href="https://jorgedfbranco.github.io/posts/implementing-a-scheduler-in-java/">
				<span class="post-nav-label">Older&nbsp;<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-right"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg></span><br><span>Implementing a Scheduler in Java</span>
			</a>
		</div>
		<div id="comments" class="thin">
</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2021 <a href="https://jorgedfbranco.github.io">Jorge Branco</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://jorgedfbranco.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://jorgedfbranco.github.io/js/bundle.min.c048d1b7b0dfdbf1acd4dbd8544a2443fd6da4779e066fe86af64ad37eed258a.js" integrity="sha256-wEjRt7Df2/Gs1NvYVEokQ/1tpHeeBm/oavZK037tJYo=" crossorigin="anonymous"></script>
	

</body>

</html>
