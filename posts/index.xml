<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Jorge Branco&#39;s Blog</title>
		<link>https://jorgedfbranco.github.io/posts/</link>
		<description>Recent content in Posts on Jorge Branco&#39;s Blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 20 Sep 2021 00:00:00 +0000</lastBuildDate>
		<atom:link href="https://jorgedfbranco.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>HotSpot JVM: Thread-Local Allocation Buffers</title>
			<link>https://jorgedfbranco.github.io/posts/hotspot-jvm-thread-local-allocation-buffers/</link>
			<pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
			
			<guid>https://jorgedfbranco.github.io/posts/hotspot-jvm-thread-local-allocation-buffers/</guid>
			<description>Introduction Applications developed in managed languages running on top of a virtual-machine like the JVM or the CLR tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&amp;rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&amp;rsquo;s heap.
Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &amp;ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen.</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Applications developed in managed languages running on top of a virtual-machine like the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine">JVM</a> or the <a href="https://en.wikipedia.org/wiki/Common_Language_Runtime">CLR</a> tend to create inordinate amounts of objects, as developers are freed from having to manually take care of managing the created object&rsquo;s life-cycles. If not for the occasional object allocation optimized away by a smart compiler, most object creation involves the allocation of memory in the application&rsquo;s heap.</p>
<p>Given that nowadays most applications are multi-threaded, allocating an object on the heap can be troublesome &ndash; multiple threads may attempt to do it concurrently and unless some sort of synchronization logic is involved, malign data-races are bound to happen. Wrapping the allocation function with a lock will make sure the allocation logic is correct but will induce serious performance degradation &ndash; the higher the number of threads and quantity of allocation requests per unit of time, the higher the pressure on the lock and the slower requests will end up served.</p>
<p>To minimize the problem, most modern VMs will in a way or another use the concept of a <code>thread-local allocation buffer</code> (TLAB). Instead of having threads perform hundreds of requests per second to the heap, it&rsquo;s preferable to have them request huge chunk of memory from time to time. They can then in a thread-local, unsynchronized way allocate all objects from that local chunk (buffer) at very high speeds. Only when that buffer runs out of available memory shall the thread make another request to the heap.</p>
<h2 id="hotspot">HotSpot</h2>
<p>The aim of this article is to investigate how TLABs are implemented on the HotSpot VM and go over a couple of their most commmon use-cases:</p>
<ol>
<li>How and when are they initialized? To what size?</li>
<li>How is memory allocated from them, namely, when creating an object?</li>
<li>How are they refilled when running out of available memory?</li>
<li>How are they dealt with when a thread dies?</li>
</ol>
<p>For that we&rsquo;ll go over HotSpot&rsquo;s <code>Thread</code> and <code>ThreadLocalAllocBuffer</code> classes, where TLAB&rsquo;s core logic resides.</p>
<h3 id="thread-implementation">Thread Implementation</h3>
<p>The base thread definition / implementation in HotSpot is at <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.hpp">thread.hpp</a> / <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp">thread.cpp</a>. It&rsquo;s quite a fat class but we&rsquo;ll keep it simple by only looking at TLAB-related fields / methods:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Thread</span><span class="o">:</span> <span class="k">public</span> <span class="n">ThreadShadow</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">ThreadLocalAllocBuffer</span> <span class="n">_tlab</span><span class="p">;</span>                 <span class="c1">// Thread-local eden
</span><span class="c1"></span>    <span class="p">...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// Thread-Local Allocation Buffer (TLAB) support
</span><span class="c1"></span>        <span class="n">ThreadLocalAllocBuffer</span><span class="o">&amp;</span> <span class="n">tlab</span><span class="p">()</span>                 <span class="p">{</span> <span class="k">return</span> <span class="n">_tlab</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="nf">initialize_tlab</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.hpp#L132">thread.hpp:132</a></p>
</span>
</div>
<p>When the <code>Thread</code> class is first created, an un-initialized TLAB structure is inlined in the <code>Thread</code> object. But it will only get initialized the moment a call to <code>JavaThread::run()</code> is performed:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// The main routine called by a new Java thread. This isn&#39;t overridden
</span><span class="c1">// by subclasses, instead different subclasses define a different &#34;entry_point&#34;
</span><span class="c1">// which defines the actual logic for that kind of thread.
</span><span class="c1"></span><span class="kt">void</span> <span class="n">JavaThread</span><span class="o">::</span><span class="n">run</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// initialize thread-local alloc buffer related fields
</span><span class="c1"></span>    <span class="n">initialize_tlab</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L1229">thread.cpp:1229</a></p>
</span>
</div>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">Thread</span><span class="o">::</span><span class="n">initialize_tlab</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">UseTLAB</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tlab</span><span class="p">().</span><span class="n">initialize</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L284">thread.cpp:284</a></p>
</span>
</div>
<p>And, as expected, the moment the thread is killed, the TLAB is also destroyed (retired):</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">JavaThread</span><span class="o">::</span><span class="n">exit</span><span class="p">(</span><span class="kt">bool</span> <span class="n">destroy_vm</span><span class="p">,</span> <span class="n">ExitType</span> <span class="n">exit_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">UseTLAB</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tlab</span><span class="p">().</span><span class="n">retire</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/runtime/thread.cpp#L1320">thread.cpp:1320</a></p>
</span>
</div>
<p>To know what <code>tlab().initialize()</code> and <code>tlab().retire()</code> actually do, we&rsquo;ll now need to delve into the TLAB object, <code>ThreadLocalAllocBuffer</code>:</p>
<h3 id="tlab-implementation">TLAB Implementation</h3>
<h4 id="class-definition">Class Definition</h4>
<p>A TLAB is represented in HotSpot by the <code>ThreadLocalAllocBuffer</code> class:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">ThreadLocalAllocBuffer</span><span class="o">:</span> <span class="k">public</span> <span class="n">CHeapObj</span><span class="o">&lt;</span><span class="n">mtThread</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_start</span><span class="p">;</span>                              <span class="c1">// address of TLAB
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_top</span><span class="p">;</span>                                <span class="c1">// address after last allocation
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_pf_top</span><span class="p">;</span>                             <span class="c1">// allocation prefetch watermark
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_end</span><span class="p">;</span>                                <span class="c1">// allocation end (can be the sampling end point or _allocation_end)
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">_allocation_end</span><span class="p">;</span>                     <span class="c1">// end for allocations (actual TLAB end, excluding alignment_reserve)
</span><span class="c1"></span>
    <span class="n">size_t</span>    <span class="n">_desired_size</span><span class="p">;</span>                       <span class="c1">// desired size   (including alignment_reserve)
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_refill_waste_limit</span><span class="p">;</span>                 <span class="c1">// hold onto tlab if free() is larger than this
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_allocated_before_last_gc</span><span class="p">;</span>           <span class="c1">// total bytes allocated up until the last gc
</span><span class="c1"></span>    <span class="n">size_t</span>    <span class="n">_bytes_since_last_sample_point</span><span class="p">;</span>      <span class="c1">// bytes since last sample point.
</span><span class="c1"></span>
    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp#L46">threadLocalAllocBuffer.hpp:46</a></p>
</span>
</div>
<p>from which the most important fields are:</p>
<ul>
<li><code>_start</code> - a pointer to the starting address of this TLAB;</li>
<li><code>_top</code> - a pointer to the address of the last allocation, or equivalently, where the next object is going to be allocated on this TLAB;</li>
<li><code>_end</code> - a pointer to the end of this TLAB.</li>
</ul>
<p>As we&rsquo;re going to see in the next section, allocations on a TLAB should be a relatively inexpensive operation:</p>
<h4 id="allocation">Allocation</h4>
<p>Allocation happens in a relatively straightforward way: as long as there&rsquo;s enough space in the TLAB, allocating <code>size</code> amount of memory out of a TLAB can be as simple as bumping up <code>_top</code> by <code>size</code>:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kr">inline</span> <span class="n">HeapWord</span><span class="o">*</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">allocate</span><span class="p">(</span><span class="n">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">HeapWord</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">top</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pointer_delta</span><span class="p">(</span><span class="n">end</span><span class="p">(),</span> <span class="n">obj</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">set_top</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp#L38">threadLocalAllocBuffer.inline.hpp:38</a></p>
</span>
</div>
<p>In the bytecode interpreter, for instance, when an allocation request comes in, here&rsquo;s how <code>ThreadLocalAllocBuffer::allocate()</code> ends up invoked:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">BytecodeInterpreter</span><span class="o">::</span><span class="n">run</span><span class="p">(</span><span class="n">interpreterState</span> <span class="n">istate</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">CASE</span><span class="p">(</span><span class="n">_new</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span>
            <span class="p">...</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ik</span><span class="o">-&gt;</span><span class="n">is_initialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">ik</span><span class="o">-&gt;</span><span class="n">can_be_fastpath_allocated</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">size_t</span> <span class="n">obj_size</span> <span class="o">=</span> <span class="n">ik</span><span class="o">-&gt;</span><span class="n">size_helper</span><span class="p">();</span>
                <span class="n">HeapWord</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">THREAD</span><span class="o">-&gt;</span><span class="n">tlab</span><span class="p">().</span><span class="n">allocate</span><span class="p">(</span><span class="n">obj_size</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">oop</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">cast_to_oop</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>

                    <span class="c1">// Initialize header
</span><span class="c1"></span>                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_mark</span><span class="p">(</span><span class="n">markWord</span><span class="o">::</span><span class="n">prototype</span><span class="p">());</span>
                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_klass_gap</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="n">obj</span><span class="o">-&gt;</span><span class="n">set_klass</span><span class="p">(</span><span class="n">ik</span><span class="p">);</span>

                    <span class="c1">// Must prevent reordering of stores for object initialization
</span><span class="c1"></span>                    <span class="c1">// with stores that publish the new object.
</span><span class="c1"></span>                    <span class="n">OrderAccess</span><span class="o">::</span><span class="n">storestore</span><span class="p">();</span>
                    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp#L405">bytecodeInterpreter.cpp:405</a></p>
</span>
</div>
<p>otherwise, a slower and costlier path is followed that ends up performing direct allocations on the Heap itself:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// Slow case allocation
</span><span class="c1"></span><span class="n">CALL_VM</span><span class="p">(</span><span class="n">InterpreterRuntime</span><span class="o">::</span><span class="n">_new</span><span class="p">(</span><span class="n">THREAD</span><span class="p">,</span> <span class="n">METHOD</span><span class="o">-&gt;</span><span class="n">constants</span><span class="p">(),</span> <span class="n">index</span><span class="p">),</span> <span class="n">handle_exception</span><span class="p">);</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/zero/bytecodeInterpreter.cpp#L1870">bytecodeInterpreter.cpp:1870</a></p>
</span>
</div>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">JRT_ENTRY</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">InterpreterRuntime</span><span class="o">::</span><span class="n">_new</span><span class="p">(</span><span class="n">JavaThread</span><span class="o">*</span> <span class="n">current</span><span class="p">,</span> <span class="n">ConstantPool</span><span class="o">*</span> <span class="n">pool</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">))</span>
    <span class="n">Klass</span><span class="o">*</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pool</span><span class="o">-&gt;</span><span class="n">klass_at</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">CHECK</span><span class="p">);</span>
    <span class="n">InstanceKlass</span><span class="o">*</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">InstanceKlass</span><span class="o">::</span><span class="n">cast</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>

    <span class="p">...</span>
    <span class="n">oop</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">klass</span><span class="o">-&gt;</span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">CHECK</span><span class="p">);</span>
    <span class="p">...</span>
<span class="n">JRT_END</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/interpreter/interpreterRuntime.cpp#L217">interpreterRuntime.cpp:217</a></p>
</span>
</div>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">instanceOop</span> <span class="n">InstanceKlass</span><span class="o">::</span><span class="n">allocate_instance</span><span class="p">(</span><span class="n">TRAPS</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">size_helper</span><span class="p">();</span>

    <span class="p">...</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">instanceOop</span><span class="p">)</span><span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">obj_allocate</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">CHECK_NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/oops/instanceKlass.cpp#L1413">instanceKlass.cpp:1413</a></p>
</span>
</div>
<h4 id="vm-parameters">VM Parameters</h4>
<p>All the VM parameters related to TLABs, such as <code>UseTLAB</code>, <code>ResizeTLAB</code>, <code>ZeroTLAB</code>, <code>MinTLABSize</code>, <code>TLABSize</code>, may be found at <code>tlab_globals.cpp</code>:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp">    <span class="p">...</span>
    <span class="cm">/* Thread Local Allocation Buffer */</span>                                      \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">UseTLAB</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                              \
            <span class="s">&#34;Use thread-local object allocation&#34;</span><span class="p">)</span>                             \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ResizeTLAB</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                           \
            <span class="s">&#34;Dynamically resize TLAB size for threads&#34;</span><span class="p">)</span>                       \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">ZeroTLAB</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>                                            \
            <span class="s">&#34;Zero out the newly created TLAB&#34;</span><span class="p">)</span>                                \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">TLABStats</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span>                                            \
            <span class="s">&#34;Provide more detailed and expensive TLAB statistics.&#34;</span><span class="p">)</span>           \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">MinTLABSize</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">K</span><span class="p">,</span>                                         \
            <span class="s">&#34;Minimum allowed TLAB size (in bytes)&#34;</span><span class="p">)</span>                           \
            <span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_uintx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>                                             \
            <span class="n">constraint</span><span class="p">(</span><span class="n">MinTLABSizeConstraintFunc</span><span class="p">,</span><span class="n">AfterMemoryInit</span><span class="p">)</span>             \
                                                                              \
    <span class="n">product</span><span class="p">(</span><span class="n">size_t</span><span class="p">,</span> <span class="n">TLABSize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>                                              \
            <span class="s">&#34;Starting TLAB size (in bytes); zero means set ergonomically&#34;</span><span class="p">)</span>    \
            <span class="n">constraint</span><span class="p">(</span><span class="n">TLABSizeConstraintFunc</span><span class="p">,</span><span class="n">AfterMemoryInit</span><span class="p">)</span>                \
    <span class="p">...</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/tlab_globals.hpp#L38">tlab_globals.hpp:38</a></p>
</span>
</div>
<h4 id="initialization-and-refill">Initialization and Refill</h4>
<p>The allocation of the region of memory used by a TLAB is, and maybe surprisingly, always external to this class. It&rsquo;s always up to the caller of <code>ThreadLocalAllocBuffer</code> to correctly allocate a memory region <code>R</code> and call <code>ThreadLocalAllocBuffer::fill(start, top, new_size)</code> to make the TLAB be aware of, and use, <code>R</code>.</p>
<p>In pratical terms, the first time a memory region is associated with a TLAB is when a thread&rsquo;s first allocation request comes in and fails:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">HeapWord</span><span class="o">*</span> <span class="n">MemAllocator</span><span class="o">::</span><span class="n">allocate_inside_tlab</span><span class="p">(</span><span class="n">Allocation</span><span class="o">&amp;</span> <span class="n">allocation</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// Try allocating from an existing TLAB.
</span><span class="c1"></span>    <span class="n">HeapWord</span><span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="n">_thread</span><span class="o">-&gt;</span><span class="n">tlab</span><span class="p">().</span><span class="n">allocate</span><span class="p">(</span><span class="n">_word_size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Try refilling the TLAB and allocating the object in it.
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">allocate_inside_tlab_slow</span><span class="p">(</span><span class="n">allocation</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">HeapWord</span><span class="o">*</span> <span class="n">MemAllocator</span><span class="o">::</span><span class="n">allocate_inside_tlab_slow</span><span class="p">(</span><span class="n">Allocation</span><span class="o">&amp;</span> <span class="n">allocation</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">size_t</span> <span class="n">min_tlab_size</span> <span class="o">=</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">compute_min_size</span><span class="p">(</span><span class="n">_word_size</span><span class="p">);</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">allocate_new_tlab</span><span class="p">(</span><span class="n">min_tlab_size</span><span class="p">,</span> <span class="n">new_tlab_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allocation</span><span class="p">.</span><span class="n">_allocated_tlab_size</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="n">tlab</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">mem</span> <span class="o">+</span> <span class="n">_word_size</span><span class="p">,</span> <span class="n">allocation</span><span class="p">.</span><span class="n">_allocated_tlab_size</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/memAllocator.cpp#L268">memAllocator.cpp:268</a></p>
</span>
</div>
<p>This is, of course, the very same code-path that&rsquo;s executed when, after a sequence of allocations, the TLAB gets full and a new allocation from the heap is needed to refill it.</p>
<h4 id="sizing">Sizing</h4>
<p>The TLAB size can be hard-coded and passed as a JVM parameter (<code>TLABSize</code>), or calculated on-the-fly:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">size_t</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">initial_desired_size</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">size_t</span> <span class="n">init_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TLABSize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init_sz</span> <span class="o">=</span> <span class="n">TLABSize</span> <span class="o">/</span> <span class="n">HeapWordSize</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// Initial size is a function of the average number of allocating threads.
</span><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nof_threads</span> <span class="o">=</span> <span class="n">ThreadLocalAllocStats</span><span class="o">::</span><span class="n">allocating_threads_avg</span><span class="p">();</span>

    <span class="n">init_sz</span>  <span class="o">=</span> <span class="p">(</span><span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">tlab_capacity</span><span class="p">(</span><span class="kr">thread</span><span class="p">())</span> <span class="o">/</span> <span class="n">HeapWordSize</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">nof_threads</span> <span class="o">*</span> <span class="n">target_refills</span><span class="p">());</span>
    <span class="n">init_sz</span> <span class="o">=</span> <span class="n">align_object_size</span><span class="p">(</span><span class="n">init_sz</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">init_sz</span> <span class="o">=</span> <span class="n">MIN2</span><span class="p">(</span><span class="n">MAX2</span><span class="p">(</span><span class="n">init_sz</span><span class="p">,</span> <span class="n">min_size</span><span class="p">()),</span> <span class="n">max_size</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">init_sz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L268">threadLocalAllocBuffer.cpp:268</a></p>
</span>
</div>
<h4 id="death">Death</h4>
<p>Finally, what happens when a thread is about do die? It turns out that whatever space is still unused will be used to allocate a dummy integer array:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">retire</span><span class="p">(</span><span class="n">ThreadLocalAllocStats</span><span class="o">*</span> <span class="n">stats</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">thread</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">incr_allocated_bytes</span><span class="p">(</span><span class="n">used_bytes</span><span class="p">());</span>
      <span class="n">insert_filler</span><span class="p">();</span>
      <span class="n">initialize</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L137">threadLocalAllocBuffer.cpp:137</a></p>
</span>
</div>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">ThreadLocalAllocBuffer</span><span class="o">::</span><span class="n">insert_filler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">hard_end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">Universe</span><span class="o">::</span><span class="n">heap</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">fill_with_dummy_object</span><span class="p">(</span><span class="n">top</span><span class="p">(),</span> <span class="n">hard_end</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp#L119">threadLocalAllocBuffer.cpp:119</a></p>
</span>
</div>
<p><code>CollectedHeap::fill_with_dummy_object()</code> will, after a sequence of calls end up at:</p>
<div style="background-color: #2c3e50;">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="n">CollectedHeap</span><span class="o">::</span><span class="n">fill_with_array</span><span class="p">(</span><span class="n">HeapWord</span><span class="o">*</span> <span class="n">start</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">words</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">zap</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">const</span> <span class="n">size_t</span> <span class="n">payload_size</span> <span class="o">=</span> <span class="n">words</span> <span class="o">-</span> <span class="n">filler_array_hdr_size</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">payload_size</span> <span class="o">*</span> <span class="n">HeapWordSize</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">jint</span><span class="p">);</span>

    <span class="n">ObjArrayAllocator</span> <span class="nf">allocator</span><span class="p">(</span><span class="n">Universe</span><span class="o">::</span><span class="n">intArrayKlassObj</span><span class="p">(),</span> <span class="n">words</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">len</span><span class="p">,</span> <span class="cm">/* do_zero */</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">allocator</span><span class="p">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><span style="font-family: Roboto; display: block; margin-top: -16px; margin-left: 8px; text-align: right;">
<p><i>Source File</i>: <a href="https://github.com/openjdk/jdk/blob/jdk-18%2B15/src/hotspot/share/gc/shared/collectedHeap.cpp#L425">collectedHeap.cpp:425</a></p>
</span>
</div>
<h2 id="conclusion">Conclusion</h2>
<p>We covered a simplified view of how TLABs work in HotSpot, and this should be more than enough to get one going if wanting to dive deeper. Be aware that not all GCs will use <code>ThreadLocalAllocBuffer</code>. The ZGC collector, for instance, will use its own implementation of a TLAB through its <code>ZThreadLocalAllocBuffer</code> class.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://alidg.me/blog/2019/6/21/tlab-jvm">Thread-Local Allocation Buffers in JVM</a></li>
<li><a href="https://shipilev.net/jvm/anatomy-quarks/4-tlab-allocation/">JVM Anatomy Quark #4: TLAB allocation</a></li>
<li><a href="https://programmerclick.com/article/3946498271/">An치lisis de c칩digo fuente JVM G1 - asignaci칩n de espacio de mont칩n para objetos</a></li>
<li><a href="https://programmer.ink/think/thread-local-cache-tlab-for-jvm-source-analysis.html">Thread Local Cache TLAB for JVM Source Analysis</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Implementing a Scheduler in Java</title>
			<link>https://jorgedfbranco.github.io/posts/implementing-a-scheduler-in-java/</link>
			<pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate>
			
			<guid>https://jorgedfbranco.github.io/posts/implementing-a-scheduler-in-java/</guid>
			<description>Introduction The goal of this article is to implement a simple Scheduler class, allowing us to both schedule tasks (Runnable instances) that are only to be run once, as well as tasks that can be run repeatedly at a given frequency:
interface Scheduler { public void schedule(LocalDateTime startTime, Runnable runnable); public void schedulePeriodic(LocalDateTime startTime, Duration frequency, Runnable runnable); } There are two possible strategies to design such a scheduler:
  Using condition variables - We store submitted tasks in a tasks priority queue, where tasks are ordered by their schedule date.</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>The goal of this article is to implement a simple <code>Scheduler</code> class, allowing us to both schedule tasks (<code>Runnable</code> instances) that are only to be run once, as well as tasks that can be run repeatedly at a given frequency:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nc">Scheduler</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">schedule</span><span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">startTime</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">);</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">schedulePeriodic</span><span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">startTime</span><span class="o">,</span> <span class="n">Duration</span> <span class="n">frequency</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>There are two possible strategies to design such a scheduler:</p>
<ol>
<li>
<p>Using <a href="/posts/condition-variables-in-java">condition variables</a> - We store submitted tasks in a <code>tasks</code> priority queue, where tasks are ordered by their schedule date. A scheduling thread is permanently kept running &ndash; it&rsquo;s most of the time doing a timed wait until the task scheduled next needs to be executed. It will then wake up, run the scheduled task, and go back to another timed wait. New tasks submitted to the scheduler will not interfere with the scheduling thread unless the newly submitted task is to be run at an earlier date than any of the tasks currently sitting on the <code>tasks</code> queue. In that case, a notification is sent to the scheduling thread to force a wake-up and recalculation of what the next timed wait is going to be. The process repeats ad eternum. This is the approach followed by Java&rsquo;s <code>java.util.concurrent.ScheduledThreadPoolExecutor</code>.</p>
</li>
<li>
<p>Use a &ldquo;Hashed Wheel Timer&rdquo; - We store the submitted tasks in a <code>tasks</code> priority queue, where tasks are ordered by their schedule date. A scheduling thread is permanently kept running, and it&rsquo;s awakened every, let&rsquo;s say, 100ms. It then checks for all the tasks that are scheduled for any date up to <code>now() + 100ms</code>. It drains them from the queue, executes them, and then goes back to sleep for the next 100ms. The process is repeated ad eternum. This is, on the other hand, the approach followed by <a href="https://github.com/akka/akka/blob/master/akka-actor/src/main/scala/akka/actor/LightArrayRevolverScheduler.scala">Akka&rsquo;s scheduler</a> and by <a href="https://docs.jboss.org/netty/3.1/api/org/jboss/netty/util/HashedWheelTimer.html">netty&rsquo;s scheduler</a>.</p>
</li>
</ol>
<h2 id="implementation">Implementation</h2>
<p>In this article, we&rsquo;re going down route #1, although approach #2 is most likely easier to implement..</p>
<p>As described, the crux of the algorithm is a priority queue of <code>Task</code>s that need to be ordered by their scheduled <code>startTime</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scheduler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">tasks</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PriorityQueue</span><span class="o">&lt;&gt;();</span>
    <span class="o">...</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="n">record</span> <span class="nf">Task</span><span class="o">(</span>
        <span class="n">LocalDateTime</span> <span class="n">startTime</span><span class="o">,</span>
        <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">frequency</span><span class="o">,</span>
        <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">,</span>
        <span class="n">Optional</span><span class="o">&lt;</span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;&gt;</span> <span class="n">future</span>
    <span class="o">)</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">Task</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">startTime</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o</span><span class="o">.</span><span class="na">startTime</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>We then need to ask ourselves the following question:</p>
<h2 id="should-tasks-run-on-the-scheduling-thread">Should tasks run on the scheduling thread?</h2>
<p>The scheduler itself will always need to run on a thread of its own, but when the time comes to finally run a given task, we may either run it directly on the scheduling thread or spawn it on a new thread, or in a thread belonging to a thread-pool.</p>
<p>Running arbitrary tasks on the scheduling thread is risky, as there are no guarantees that the task is going to run quick, or even that will ever terminate &ndash; and that puts the whole scheduler in jeopardy.</p>
<p>For that reason, all schedulers will in general spawn their tasks in alternate threads. Our scheduler will take an already existing <code>ExecutorService</code> in its constructor and will execute all its tasks on it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scheduler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Thread</span> <span class="n">schedulingThread</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ExecutorService</span> <span class="n">executorService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Scheduler</span><span class="o">(</span><span class="n">ExecutorService</span> <span class="n">executorService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">executorService</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="scheduling-thread-creation">Scheduling Thread Creation</h2>
<p>There are two times when the scheduling thread may be created: either eagerly when instantiating a <code>Scheduler</code> object or lazily when the first task gets submitted.</p>
<p>From a practical perspective, a scheduling thread is only needed from the moment a task is submitted, as if it gets created before that time it&rsquo;s just going to be sleeping. It then only really needs to live until there are no further tasks to be processed. It could by that time be immediately destroyed, or it may be kept alive either indefinitely or temporarily, just in case new tasks may arrive in the near future. Destroying it too early may mean having threads being recurrently created and destroyed for no good reason, keeping it forever alive may also be a waste of resources if no new tasks end up being submitted to the scheduler.</p>
<p>For simplicity, in this implementation the thread will be created at instantiation time.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Scheduler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Thread</span> <span class="n">schedulingThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">scheduler</span><span class="o">);</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="nf">Scheduler</span><span class="o">(</span><span class="n">ExecutorService</span> <span class="n">executorService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">executorService</span> <span class="o">=</span> <span class="n">executorService</span><span class="o">;</span>
        <span class="n">schedulingThread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="o">...</span>
</code></pre></div><h2 id="scheduling-of-tasks">Scheduling of Tasks</h2>
<p>Scheduling a task entails entering a synchronize block, wrapping the given <code>Runnable</code> in a <code>Task</code> object, and in case we determine this newly created task to be the earliest task in the queue, warn the scheduling thread that it needs to update its timed wait:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">CompletionStage</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">schedule</span><span class="o">(</span><span class="n">LocalDateTime</span> <span class="n">startTime</span><span class="o">,</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Duration</span><span class="o">&gt;</span> <span class="n">frequency</span><span class="o">,</span> <span class="n">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">schedulingThread</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">var</span> <span class="n">future</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;();</span>
        <span class="n">var</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Task</span><span class="o">(</span><span class="n">startTime</span><span class="o">,</span> <span class="n">frequency</span><span class="o">,</span> <span class="n">runnable</span><span class="o">,</span> <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">future</span><span class="o">));</span>
        <span class="n">tasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">tasks</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">==</span> <span class="n">task</span><span class="o">)</span>
            <span class="n">schedulingThread</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">future</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="the-scheduling-thread">The Scheduling Thread</h2>
<p>The scheduler thread will sleep indefinitely if there are no tasks in sight. The moment one is found, a timed wait is performed. We need to be aware that there are no guarantees that the timed wait is going to be accurate &ndash; there may be jitter, there may be a long garbage-collection pause, or any it may be that the underling scheduler or clock is not that precise. We should take into consideration that when our thread wakes up there may be tasks to be processed from earlier dates. For the aforementioned reasons, the scheduling thread will most likely lag when waking up from its sleep, but it&rsquo;s also possible that it may be slightly ahead at times. This could introduce an interesting problem: the scheduler is supposed to wake up at <code>t</code> but wakes up at <code>t - 1ms</code> &ndash; what should it do now? To better deal with those situations, we may introduce a <code>milliResolution</code> parameter, that will help us define what we consider to be &ldquo;now&rdquo;. If <code>milliResolution = 2ms</code>, any task in the interval <code>[t, t + 2ms]</code> will be considered as now, and tasks in that interval will be processed immediately.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">Thread</span> <span class="n">schedulingThread</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="o">(</span><span class="k">this</span><span class="o">::</span><span class="n">scheduler</span><span class="o">);</span>

<span class="o">...</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">scheduler</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">scheduler</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(!</span><span class="n">shuttingDown</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">waitTime</span> <span class="o">=</span> <span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            <span class="n">var</span> <span class="n">now</span> <span class="o">=</span> <span class="n">LocalDateTime</span><span class="o">.</span><span class="na">now</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">tasks</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">waitTime</span> <span class="o">=</span> <span class="n">ChronoUnit</span><span class="o">.</span><span class="na">MILLIS</span><span class="o">.</span><span class="na">between</span><span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="n">tasks</span><span class="o">.</span><span class="na">peek</span><span class="o">().</span><span class="na">startTime</span><span class="o">());</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">waitTime</span> <span class="o">&lt;</span> <span class="n">milliResolution</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">var</span> <span class="n">task</span> <span class="o">=</span> <span class="n">tasks</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">executorService</span><span class="o">.</span><span class="na">submit</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="n">task</span><span class="o">.</span><span class="na">runnable</span><span class="o">().</span><span class="na">run</span><span class="o">();</span>
                    <span class="n">task</span><span class="o">.</span><span class="na">future</span><span class="o">().</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="kc">null</span><span class="o">));</span>
                <span class="o">});</span>

                <span class="n">task</span><span class="o">.</span><span class="na">frequency</span><span class="o">.</span><span class="na">ifPresent</span><span class="o">(</span><span class="n">freq</span> <span class="o">-&gt;</span>
                    <span class="n">tasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Task</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">plusNanos</span><span class="o">(</span><span class="n">freq</span><span class="o">.</span><span class="na">toNanos</span><span class="o">()),</span> <span class="n">task</span><span class="o">.</span><span class="na">frequency</span><span class="o">,</span> <span class="n">task</span><span class="o">.</span><span class="na">runnable</span><span class="o">,</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">()))</span>
                <span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">scheduler</span><span class="o">.</span><span class="na">wait</span><span class="o">(</span><span class="n">waitTime</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">ignored</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>With this, we&rsquo;ve covered from a high-level most of the scheduler implementation. The full code may be found <a href="https://gist.github.com/jorgedfbranco/1c70051111af380d8d474c457cab782b">here</a>.</p>
]]></content>
		</item>
		
		<item>
			<title>Implementing a Blocking Queue with Condition Variables</title>
			<link>https://jorgedfbranco.github.io/posts/implementing-a-blocking-queue-with-condition-variables-in-java/</link>
			<pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
			
			<guid>https://jorgedfbranco.github.io/posts/implementing-a-blocking-queue-with-condition-variables-in-java/</guid>
			<description>Introduction A concurrent blocking queue is a special kind of FIFO data-structure where:
 Calling dequeue() always returns an element, blocking the calling thread if the queue is currently empty. Only an insertion by another thread through a call to enqueue(v) will then unblock it; Calling enqueue() inserts an element in the queue. There are two variants of blocking queues: bounded and unbounded. An unbounded queue allows you to insert as many elements on it as you&amp;rsquo;d like.</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>A concurrent blocking queue is a special kind of FIFO data-structure where:</p>
<ol>
<li>Calling <code>dequeue()</code> always returns an element, blocking the calling thread if the queue is currently empty. Only an insertion by another thread through a call to <code>enqueue(v)</code> will then unblock it;</li>
<li>Calling <code>enqueue()</code> inserts an element in the queue. There are two variants of blocking queues: bounded and unbounded. An unbounded queue allows you to insert as many elements on it as you&rsquo;d like. A bounded queue has a prespecified capacity, and attempting to enqueue any elements beyond that blocks the calling thread until <code>dequeue()</code> operations by other threads make up space for it.</li>
</ol>
<p>This is actually an instance of a very well known problem: <a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">The Producer / Consumer Problem</a>.</p>
<p>Given this, the simplest and most naive implementation could make use of active polling to try to achieve the blocking behavior that both <code>dequeue()</code> and <code>enqueue()</code> methods require:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnboundedBlockingQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">data</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(!</span><span class="n">data</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                    <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>This implementation is, of course, terrible from a resource usage perspective. To avoid the constant polling, it&rsquo;d be interesting to have access to some sort of primitive allowing us to freeze any calling thread of <code>dequeue()</code> when the queue is empty, only to get unblocked when items are enqueued through any other thread.</p>
<hr>
<h2 id="condition-variables-in-java">Condition Variables in Java</h2>
<p>Fortunately, for this we can use <code>condition variables</code>. Condition variables are offered in Java through three methods implemented in <code>java.lang.Object</code> and that are available in any heap object instance: <code>Object.wait()</code> (and its overloads), <code>Object.notify()</code> and <code>Object.notifyAll()</code>:</p>
<ul>
<li><code>o.wait()</code> - Blocks (freezes) the current thread until some other thread makes a call to <code>o.notify()</code> or <code>o.notifyAll()</code>;</li>
<li><code>o.notify()</code> - Notifies (unblocks) a thread that has been previously blocked via <code>o.wait()</code>. If no thread is currently blocked it does nothing; If multiple threads were awaiting, only one of them is woken up.</li>
<li><code>o.notifyAll()</code> - Like <code>notify()</code>, but unblocks all currently blocked threads.</li>
</ul>
<p>Beware that calls to any of these three methods can only be done inside <code>synchronized</code> blocks, and can only be invoked on the same object that is currently under lock from the synchronization block.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="o">...</span>
<span class="c1">// An example of how a call to wait() / notify() / notifyAll() should look like
</span><span class="c1"></span><span class="kd">synchronized</span> <span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// &lt;-- locking &#34;o&#34;
</span><span class="c1"></span>    <span class="o">...</span>
    <span class="n">o</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>  <span class="c1">// &lt;-- invoking wait() on &#34;o&#34; 
</span><span class="c1"></span>    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div><p>Failure to do so will result in a runtime exception when attempting to invoke these methods.</p>
<p>Before we move into a full-blown blocking queue implementation, let&rsquo;s delve into how condition variables are implemented at the VM level.</p>
<hr>
<h2 id="entry-lists-and-wait-sets">Entry-Lists and Wait-Sets</h2>
<p>Every object instance <code>o</code> in Java has an associated:</p>
<ol>
<li><code>entry-list</code> - a set containing the list of threads currently awaiting to acquire a lock on <code>o</code>.</li>
<li><code>wait-set</code> - a set containing the list of threads currently waiting on a condition variable of <code>o</code>;</li>
</ol>
<p>Let&rsquo;s take a look into how both end up used:</p>
<h3 id="the-locks-entry-list">The Lock&rsquo;s Entry List</h3>
<p>When a thread <code>T</code> attempts to enter a <code>synchronized</code> block with a lock on object <code>o</code>, one of two things may happen:</p>
<ol>
<li>No other thread is currently holding the lock on <code>o</code>, so <code>T</code> is free to acquire it and enter the <code>synchronized</code>&lsquo;block&rsquo;s critical section. Eventually, when leaving the critical section, the lock is released;</li>
<li>Another thread <code>T2</code> has already acquired the lock. In this case, <code>T</code> will be added to <code>o</code>&rsquo;s <code>entry-list</code> and sent to sleep. Eventually, when <code>T2</code> frees the lock, one of the threads in the <code>entry-list</code> is removed from it and allowed to acquire the lock on <code>o</code> and proceed to enter a critical section.</li>
</ol>
<h3 id="the-wait-set">The Wait-Set</h3>
<p>When a thread is inside a <code>synchronized</code> block locking <code>o</code>, its code is allowed to make calls to <code>o.wait()</code>, <code>o.notify()</code> and <code>o.notifyAll()</code>.</p>
<ol>
<li>When thread <code>T</code> calls <code>o.wait()</code>, <code>T</code> gets added to the wait-set of <code>o</code> and the currently held lock is released, so any other thread is now free to acquire the lock.</li>
<li>When thread <code>T</code> calls <code>o.notify()</code>, one of two things happen:
<ol>
<li>Either <code>o</code>&rsquo;s <code>wait-set</code> is empty and it&rsquo;s for all effects a no-op, or</li>
<li>There is at least one thread in the <code>wait-set</code>. If that&rsquo;s the case, one of them is removed from the <code>wait-set</code> and it will immediately attempt to re-acquire the lock (getting added to the <code>entry-list</code> if the lock is already in use). Do note that on this very moment, most likely the lock is still being held by <code>T</code> &ndash; calling <code>o.notify()</code> does not release the lock.</li>
</ol>
</li>
<li>When thread <code>T</code> calls <code>o.notifyAll()</code> the behavior is quite similar to 2., except that the whole <code>wait-set</code> is drained and all its reference threads will now attempt to re-aquire the lock.</li>
</ol>
<p>It&rsquo;s important to realize that when a previously blocked thread is removed from the <code>wait-set</code>, attempts to grab the lock and eventually acquires it, it&rsquo;s going to resume execution from the place where it left of, not from the beginning of the synchronized block:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">data</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
    <span class="o">...</span> <span class="c1">// &lt;-- execution will resume from this point after data.wait() returns,
</span><span class="c1"></span>        <span class="c1">// even though calling wait() entailed having this thread be moved to
</span><span class="c1"></span>        <span class="c1">// a wait-set and releasing the currently held lock, eventually get
</span><span class="c1"></span>        <span class="c1">// removed from the wait-set, moved to the monitor&#39;s entry-list, sleep
</span><span class="c1"></span>        <span class="c1">// for a bit and then finally be awarded the lock back!
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><p>Before we proceed, we need to take a small detour into &ldquo;spurious wake-up calls&rdquo;:</p>
<h3 id="spurious-wake-up-calls">Spurious Wake-Up Calls</h3>
<p>Special care should be taken to always re-verify the condition that prompted a call to <code>wait()</code> as there are no guarantees that when that call returns, it originated from a corresponding <code>notify()</code> or <code>notifyAll()</code> invocation elsewhere. Modern JVM implementations will delegate part of its condition variable implementation to the operating system, and both in Windows and Linux there are known issues with possible unwarranted wakeups &ndash; &ldquo;spurious wake-up calls&rdquo; as they are known.</p>
<p>For more information regarding the issue:</p>
<ul>
<li>On Windows: <a href="https://devblogs.microsoft.com/oldnewthing/20180201-00/?p=97946">Spurious wake-ups in Win32 condition variables</a>;</li>
<li>On Linux: <a href="https://stackoverflow.com/a/1051816/130758">Do spurious wakeups in Java actually happen?</a>.</li>
</ul>
<p>The bottom-line is, for all purposes, that the pattern</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">my_condition</span><span class="o">)</span>
   <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</code></pre></div><p>should as a general rule be substituted by</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="k">while</span> <span class="o">(</span><span class="n">my_condition</span><span class="o">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</code></pre></div><hr>
<h2 id="an-unbounded-blocking-queue-implementation">An Unbounded Blocking Queue Implementation</h2>
<p>With all the gathered understanding about condition variables, it&rsquo;s quite straight-forward to come up with an unbounded blocking queue implementation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">UnboundedBlockingQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">)</span>
                <span class="n">data</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">data</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span>
                <span class="n">data</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span> <span class="c1">// for the given example, we only need to wake up a thread 
</span><span class="c1"></span>                               <span class="c1">// if the queue was previously empty
</span><span class="c1"></span>        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>We can now proceed to think of the bounded case &ndash; what if the queue should also block when attempting to add an element past a given predefined capacity?</p>
<h2 id="a-bounded-blocking-queue-implementation">A Bounded Blocking Queue Implementation</h2>
<p>The situation here gets a bit more dicey, as for the first time we have two independent conditions to check for: on enqueueings we may want to block if the queue is already at max capacity and on dequeueings if the queue is currently empty. At first sight, we could easily solve this by defining two different objects that would each hold a condition variable:</p>
<ul>
<li><code>emptyCond</code> - to be used to block the calling thread when the queue is empty;</li>
<li><code>fullCond</code> - to be used to block the calling thread when the queue is at capacity;</li>
</ul>
<p>Something ressembling:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoundedBlockingQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">emptyCond</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Object</span> <span class="n">fullCond</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="o">();</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">)</span>
                <span class="n">emptyCond</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>

            <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">fullCond</span><span class="o">.</span><span class="na">notify</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>But unfortunately, that won&rsquo;t really work as we&rsquo;re synchronizing over <code>data</code> while invoking <code>wait()</code> and <code>notify()</code> over <code>emptyCond</code> and <code>fullCond</code>, which throws an exception at runtime. The way to go around this is through the use of <code>notifyAll()</code> &ndash; we&rsquo;ll keep synchronizing, waiting and notifying over <code>data</code>, but when it comes time to notify, we always notify all threads in the <code>wait-set</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoundedBlockingQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">16</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="o">)</span>
                <span class="n">data</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
            <span class="n">data</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="n">data</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">data</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">data</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
            <span class="n">T</span> <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">data</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>This should guarantee us correct results, but unfortunately it&rsquo;s severely lacking when it comes to performance. Can we do better?</p>
<h2 id="extrinsic-locks-and-condition-variables">Extrinsic Locks and Condition Variables</h2>
<p>When referring to locks and condition variables, we&rsquo;ve been so far exclusively discussing <code>intrinsic locks</code>, that is, locks provided at the syntax and language level &ndash; locks provided by the <code>synchronized</code> keyword and by calls to <code>Object.wait()</code> and <code>Object.notify()</code> and their derivatives.</p>
<p>Java 1.5 introduced the <code>java.util.concurrent</code> package, bringing along a wealth of useful concurrency-related utilities. One of the newly introduced interfaces is <code>java.util.concurrent.locks.Lock</code>, the base interface for all new pure library-based lock implementations. As these new locks are not part of the language / virtual-machine per se, they&rsquo;re commonly referred to as <code>extrinsic locks</code>.</p>
<p>Protecting a critical section of code with an extrinsic lock can then be done as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span> <span class="c1">// one of the implementation classes of Lock
</span><span class="c1"></span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="o">....</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>As there&rsquo;s no language support for these locks, it&rsquo;s of course up to the developer to make sure that we lock and unluck in the correct order, no matter what. The advantage of the <code>Lock</code> interface, though, is that it provides some more methods, such as <code>Lock.tryLock(): bool</code>, a method that attempts to grab the lock and if failed, immediately returns false or <code>Lock.tryLock(timeout): bool</code> that attempts to grab a lock up to a given <code>timeout</code> time, returning false if no lock could be acquired during that time window.</p>
<p>The main advantage of using extrinsic locks, though, is that they allow you to create multiple condition variables over a single lock &ndash; it&rsquo;s as simple as calling:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="n">Condition</span> <span class="n">emptyCond</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
<span class="n">Condition</span> <span class="n">fullCond</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
</code></pre></div><p>and making use of its <code>await()</code> and <code>signal()</code> methods:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="o">)</span>
            <span class="n">fullCond</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
        <span class="n">data</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
        <span class="n">emptyCond</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><p>With this in place, we have all we need to come up with a final version of our bounded blocking queue implementation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BoundedBlockingQueue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">capacity</span> <span class="o">=</span> <span class="n">16</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Deque</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;();</span>

    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">emptyCond</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">Condition</span> <span class="n">fullCond</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">enqueue</span><span class="o">(</span><span class="n">T</span> <span class="n">v</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;=</span> <span class="n">capacity</span><span class="o">)</span>
                <span class="n">fullCond</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
            
            <span class="n">data</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">1</span><span class="o">)</span>
                <span class="n">emptyCond</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">T</span> <span class="nf">dequeue</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            
            <span class="k">while</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span>
                <span class="n">emptyCond</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>

            <span class="n">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span>
                <span class="n">fullCond</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="references">References</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">Monitor (Synchronization)</a></li>
<li><a href="http://lass.cs.umass.edu/~shenoy/courses/fall10/lectures/Lec09_notes.pdf">CMPSCI 377 - Operating Systems, Lecture 9: Feb 18. Monitors and Condition Variables</a></li>
<li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">Condition Variables</a></li>
<li><a href="https://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again">Java: notify() vs notifyAll() all over again</a></li>
<li><a href="https://stackoverflow.com/a/1051816/130758">Do spurious wakeups in Java actually happen?</a></li>
<li><a href="https://stackoverflow.com/a/1461956/130758">Does C# Monitor.Wait() suffer from spurious wakeups?</a></li>
<li><a href="https://devblogs.microsoft.com/oldnewthing/20180201-00/?p=97946">Spurious wake-ups in Win32 condition variables</a></li>
<li><a href="https://stackoverflow.com/questions/18490636/condition-give-the-effect-of-having-multiple-wait-sets-per-object">Condition give the effect of having multiple wait-sets per object?</a></li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>Writing an Expression Evaluator with Recursive-Descent Parsing</title>
			<link>https://jorgedfbranco.github.io/posts/writing-an-expression-evaluator-with-recursive-descent-parsing/</link>
			<pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
			
			<guid>https://jorgedfbranco.github.io/posts/writing-an-expression-evaluator-with-recursive-descent-parsing/</guid>
			<description>Introduction Let&amp;rsquo;s consider the problem of implementing a function evalExpr(str): int that, given an arbitrary well-formed mathematical expression, calculates its value.
Examples of such calls and their respective return values would be:
 evalExpr(&amp;quot;1 + 2 * 3 / 4 - 1&amp;quot;) = 1. evalExpr(&amp;quot;1 * (2 + 3)&amp;quot;) = 5.  How to go about it? A classical approach to mathematical expression parsing is to use Dijkstra&amp;rsquo;s Shunting-yard algorithm, but in this article we&amp;rsquo;re going to focus on solving it with a recursive-descent parser, as it&amp;rsquo;s a more general approach that also lends itself easier to later expand into a more fully developed language.</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Let&rsquo;s consider the problem of implementing a function <code>evalExpr(str): int</code> that, given an arbitrary well-formed mathematical expression, calculates its value.</p>
<p>Examples of such calls and their respective return values would be:</p>
<ul>
<li><code>evalExpr(&quot;1 + 2 * 3 / 4 - 1&quot;) = 1</code>.</li>
<li><code>evalExpr(&quot;1 * (2 + 3)&quot;) = 5</code>.</li>
</ul>
<p>How to go about it? A classical approach to mathematical expression parsing is to use Dijkstra&rsquo;s <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">Shunting-yard algorithm</a>, but in this article we&rsquo;re going to focus on solving it with a <strong>recursive-descent</strong> parser, as it&rsquo;s a more general approach that also lends itself easier to later expand into a more fully developed language.</p>
<p>The approach will be to define a <strong>context-free grammar</strong> (CFG) first and once we&rsquo;re confident that it correctly describes our little mathematical language and that it can be realistically lead to a functioning parser, we&rsquo;ll proceed to create a recursive-descent parser out of it.</p>
<p>Turning a CFG into such a parser is for the most part a relatively straight-forward, albeit repetitive, process. Each non-terminal will be turned into a method of the same name, where all its productions are then processed. Terminal references lead to consumed characters while non-terminals will be turned into method calls.</p>
<p>Although implementations may slightly differ, the following set of productions of a given grammar</p>
<pre><code>A -&gt; B '+' C
   | B '-' D
</code></pre><p>could be turned into:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kt">void</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">B</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">consumeChr</span><span class="o">(</span><span class="sc">&#39;+&#39;</span><span class="o">))</span>
    <span class="n">C</span><span class="o">();</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">consumeChr</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">))</span>
    <span class="n">D</span><span class="o">();</span>
  <span class="k">else</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;Invalid input string.&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>The conversion process is quite mechanical, and is one of the main selling points of recursive-descent parsers.</p>
<h2 id="defining-the-grammar-a-first-stab">Defining the Grammar: A First Stab</h2>
<p>We&rsquo;ll now come up with a grammar that describes the full set of strings our little program is able to process, that is, the parser&rsquo;s language:</p>
<pre><code>S -&gt; S '+' S
   | S '-' S
   | S '*' S
   | S '/' S
   | '(' S ')'
   | int
</code></pre><p>This grammar will indeed accept any correctly formed mathematical expression, and it&rsquo;s going to reject all other input strings. Unfortunately, there are more earthly concerns to take into consideration when coming up with a grammar, and the above shown grammar fails on multiple fronts on that regard.</p>
<p>Let&rsquo;s go through the problems the above grammar presents:</p>
<h3 id="problem-1-ambiguity">Problem 1: Ambiguity</h3>
<p>The grammar as presently stated is ambiguous. An ambiguous grammar contains multiple possible leftmost-derivations of at least a subset of the accepted input strings:</p>
<p>For instance, the input string <code>1 / 2 / 3</code> can be derived both by</p>
<pre><code>S =&gt; S '/' S
  =&gt; (S '/' S) '/' S
  =&gt; ...
</code></pre><p>or</p>
<pre><code>S =&gt; S '/' S
  =&gt; int '/' S
  =&gt; ...
</code></pre><p>This may be a show-stopper for some sorts of parsers (especially bottom-up parsers) but needs not be for a recursive-descent one. We&rsquo;ll keep this in mind, as our final grammar will indeed be non-ambiguous.</p>
<h3 id="problem-2-lack-of-precedence-rules">Problem 2: Lack of Precedence Rules</h3>
<p>The grammar doesn&rsquo;t enforce any kind of precedence rules. Examples of possible derivations of <code>1 + 2 * 3</code>  are:</p>
<pre><code>S =&gt; S '+' S
  =&gt; S '+' (S '*' S)
  ...
  =&gt; 1 + (2 * 3) = 7
</code></pre><p>and</p>
<pre><code>S =&gt; S '*' S
  =&gt; (S '+' S) '*' S
  ...
  =&gt; (1 + 2) * 3 = 9
</code></pre><p>which is highly problematic, as we&rsquo;d like to constraint derivations to always give higher precedence to multiplicative operators.</p>
<p>To properly take into account operator precedence, we&rsquo;ll augment our grammar with a new non-terminal per precedence level &ndash; the higher a precedence level is, the &ldquo;deeper&rdquo; in the derivation the non-terminal is:</p>
<pre><code>A -&gt; A '+' A
   | A '-' A
   | B

B -&gt; B '*' B
   | B '/' B
   | C

C -&gt; '(' A ')'
   | int
</code></pre><p>With this reformulation, it&rsquo;s now guaranteed that all derivations will have the right precedence levels.</p>
<h3 id="problem-3-left-recursiveness">Problem 3: Left-Recursiveness</h3>
<p>As described in the intro, the gist of recursive-descent is to convert our grammar into some running code, where each non-terminal left-side definition <strong>X</strong> ends up as a method definition <strong>X()</strong>, and any reference to non-terminal <strong>X</strong> gets translated into a call to <strong>X()</strong>.</p>
<p>For example, the following production</p>
<pre><code>A -&gt; A '+' A
  ...
</code></pre><p>would be converted into</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">int</span> <span class="nf">A</span><span class="o">()</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">A</span><span class="o">();</span>
  <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
  <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">B</span><span class="o">();</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">op</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">-</span> <span class="n">right</span><span class="o">;</span>
  <span class="k">else</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;Invalid input string.&#34;</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>But this raises a huge problem to the grammars we have been dealing with, that the attentive reader may already have spotted: it will invariably lead to a stackoverflow! The crux of the problem is that the grammar is left-recursive, that is, we have a grammar where we can find productions with the form</p>
<pre><code>A -&gt; A ...
</code></pre><p>To make our recursive parser algorithm work, we&rsquo;ll have to find ways around it. The most obvious solution is to slightly modify the grammar shown in the previous section and make sure that productions of a given precedence level only call productions at a higher level:</p>
<pre><code>A -&gt; B '+' B
   | B '-' B

B -&gt; C '*' C
   | C '/' C

C -&gt; '(' A ')'
   | int
</code></pre><p>Beware that it&rsquo;s not necessarily enough to get rid of direct left-recursiveness &ndash; the above grammar works fine because <code>C</code> will always either consume an integer or an open bracket. If we added a 3rd production of the form</p>
<pre><code>C -&gt; '(' A ')'
   | int
   | A
</code></pre><p>the left-recursiveness would still be there and this could still, at least for some inputs, lead to stackoverflows.</p>
<h3 id="problem-4-operators-right-associativity">Problem 4: Operators Right-Associativity</h3>
<p>Addition or multiplication operators are said to be associative operators &ndash; <code>(A op B) op C = A op (B op C)</code>. Unfortunately, the same is not true for subtractions and divisions, where for instance, <code>(A / B) / C != A / (B / C)</code> for the general case. This again presents a problem, as fixing the left-recursiveness of the grammar now made our operators right-associative.</p>
<p>Luckily, we can fix the problem by reformulating our grammar as:</p>
<pre><code>A -&gt; B ['+' | '-') B]*
B -&gt; C ['*' | '/') C]*
C -&gt; '(' A ')'
   | int
</code></pre><p>so for the non-terminals <code>A</code> and <code>B</code>, the corresponding code will start by consuming the first non-terminal they find (in this case, <code>B</code> and <code>C</code>, respectively) and then, keep consuming any remaining operators followed by non-terminals if there are any. This is going to consume them left-to-right, as we need.</p>
<h2 id="final-solution">Final Solution</h2>
<h3 id="grammar">Grammar</h3>
<p>Our grammar has suffered a lot of changes throughout the article, but now it should be ready for consumption. Especially when converting it to code, it&rsquo;s quite often important to have readable names, so I adjusted the non-terminal names to something more palatable. Other than that, the grammar is exactly the same as the one we found in the previous section:</p>
<pre><code>Expr -&gt; Factor ['+' | '-') Factor]*
Factor -&gt; Term ['*' | '/') Term]*
Term -&gt; '(' Expr ')'
   | int
</code></pre><h3 id="code">Code</h3>
<p>We&rsquo;re finally ready to implement the full parser.</p>
<p>To run the parser we just need to keep track of:</p>
<ul>
<li>a reference to the original input string <code>s</code>;</li>
<li>an index variable <code>i</code> pointing to the current character under consideration in <code>s</code>.</li>
</ul>
<p>It&rsquo;s generally easier to wrap both variables in a class (<code>ExpressionParser</code> in this case), so all non-terminal methods can refer to them.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * An expression can be calculated by invoking {@code double result = ExpressionParser.parse(expr)}.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExpressionParser</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nf">ExpressionParser</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">double</span> <span class="nf">parse</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ExpressionParser</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="na">parse</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">parse</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">expression</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// non-terminals processing
</span><span class="c1"></span>
    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">expression</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">factor</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">consume</span><span class="o">(</span><span class="sc">&#39;+&#39;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">v</span> <span class="o">+=</span> <span class="n">factor</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">consume</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="n">factor</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">factor</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">term</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">consume</span><span class="o">(</span><span class="sc">&#39;*&#39;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">v</span> <span class="o">*=</span> <span class="n">term</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">consume</span><span class="o">(</span><span class="sc">&#39;/&#39;</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">v</span> <span class="o">/=</span> <span class="n">term</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">term</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">consume</span><span class="o">(</span><span class="sc">&#39;(&#39;</span><span class="o">))</span> <span class="o">{</span>
            <span class="kt">double</span> <span class="n">v</span> <span class="o">=</span> <span class="n">expression</span><span class="o">();</span>
            <span class="n">consume</span><span class="o">(</span><span class="sc">&#39;)&#39;</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">var</span> <span class="n">integer</span> <span class="o">=</span> <span class="n">consumeInt</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">integer</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span>
                <span class="k">return</span> <span class="n">integer</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="n">RuntimeException</span><span class="o">(</span><span class="s">&#34;Invalid input.&#34;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// terminals consumption
</span><span class="c1"></span>
    <span class="kd">private</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">consumeInt</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">consumeSpaces</span><span class="o">();</span>

        <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span><span class="o">))</span>
            <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">10</span> <span class="o">*</span> <span class="n">v</span> <span class="o">+</span> <span class="o">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="o">);</span>
            <span class="n">i</span><span class="o">++;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">consume</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">consumeSpaces</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="n">i</span><span class="o">++;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">consumeSpaces</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="o">)</span>
            <span class="n">i</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h2 id="leetcode-problems">LeetCode Problems</h2>
<h3 id="ternary-expression-parser">Ternary Expression Parser</h3>
<p>Link: <a href="https://leetcode.com/problems/ternary-expression-parser">https://leetcode.com/problems/ternary-expression-parser</a></p>
<p>We&rsquo;re asked to implement a ternary operator expression parser. The grammar is quite simple, but we need to be aware the return type of the function can be either an integer or a boolean.</p>
<p>Grammar:</p>
<pre><code>S -&gt; bool ('?' S ':' S)?
   | int
</code></pre><p>Code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">parseTernary</span><span class="o">(</span><span class="n">String</span> <span class="n">expression</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">TernaryParser</span><span class="o">(</span><span class="n">expression</span><span class="o">).</span><span class="na">parse</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">TernaryParser</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">s</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="nf">TernaryParser</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="n">String</span> <span class="nf">parse</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isDigit</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">v</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">String</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">1</span><span class="o">);</span>
            <span class="n">i</span><span class="o">++;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span>
                <span class="k">return</span> <span class="n">cond</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="sc">&#39;?&#39;</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">cond</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">i</span><span class="o">++;</span> <span class="c1">// consume &#39;?&#39;
</span><span class="c1"></span>                <span class="n">String</span> <span class="n">a</span> <span class="o">=</span> <span class="n">parse</span><span class="o">();</span>
                <span class="n">i</span><span class="o">++;</span> <span class="c1">// consume &#39;:&#39;
</span><span class="c1"></span>                <span class="n">String</span> <span class="n">b</span> <span class="o">=</span> <span class="n">parse</span><span class="o">();</span>
                <span class="k">return</span> <span class="n">cond</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&#34;T&#34;</span><span class="o">)</span> <span class="o">?</span> <span class="n">a</span> <span class="o">:</span> <span class="n">b</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div><h3 id="parsing-a-boolean-expression">Parsing A Boolean Expression</h3>
<p>Link: <a href="https://leetcode.com/problems/parsing-a-boolean-expression/">https://leetcode.com/problems/parsing-a-boolean-expression/</a></p>
<p>The grammar for this problem is:</p>
<pre><code>A -&gt; '!(' A ')'
   | ('|(' | '&amp;(') A (',' A)*) ')'
   | ('t' | 'f')
</code></pre><h3 id="basic-calculator-i-ii--iii">Basic Calculator I, II &amp; III</h3>
<h4 id="httpsleetcodecomproblemsbasic-calculatorhttpsleetcodecomproblemsbasic-calculator"><a href="https://leetcode.com/problems/basic-calculator/">https://leetcode.com/problems/basic-calculator/</a></h4>
<p>This problem requires a simpler grammar to the one developed in this article, as it only needs to support additions or subtractions. Our grammar would work as well, though.</p>
<h4 id="httpsleetcodecomproblemsbasic-calculator-iihttpsleetcodecomproblemsbasic-calculator-ii"><a href="https://leetcode.com/problems/basic-calculator-ii">https://leetcode.com/problems/basic-calculator-ii/</a></h4>
<p>We can use the very same grammar we developed in this article.</p>
<h4 id="httpsleetcodecomproblemsbasic-calculator-iiihttpsleetcodecomproblemsbasic-calculator-iii"><a href="https://leetcode.com/problems/basic-calculator-iii">https://leetcode.com/problems/basic-calculator-iii/</a></h4>
<p>Another rehash of <code>Basic Calculator II</code> as far as I understand it.</p>
]]></content>
		</item>
		
		<item>
			<title>An Introduction to Binary Search</title>
			<link>https://jorgedfbranco.github.io/posts/an-introduction-to-binary-search/</link>
			<pubDate>Fri, 30 Jul 2021 00:00:00 +0000</pubDate>
			
			<guid>https://jorgedfbranco.github.io/posts/an-introduction-to-binary-search/</guid>
			<description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Binary search allows us to quickly &amp;ndash; in &lt;code&gt;O(lg n)&lt;/code&gt; time &amp;ndash; find the index of a value &lt;code&gt;v&lt;/code&gt; in a sorted array &lt;code&gt;A&lt;/code&gt;. In other words, binary search is valuable because it spares us from having to exhaustively look for a value in the array (which would have been an &lt;code&gt;O(n)&lt;/code&gt; operation), as long as we know the array to be sorted.&lt;/p&gt;</description>
			<content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Binary search allows us to quickly &ndash; in <code>O(lg n)</code> time &ndash; find the index of a value <code>v</code> in a sorted array <code>A</code>. In other words, binary search is valuable because it spares us from having to exhaustively look for a value in the array (which would have been an <code>O(n)</code> operation), as long as we know the array to be sorted.</p>
<h2 id="the-vanilla-algorithm">The Vanilla Algorithm</h2>
<p>The algorithm works by firstly considering that <code>v</code>, if in the array, must exist somewhere in the interval</p>
<pre><code>I = [start, end] 
  = [0, len(A) - 1]
</code></pre>
<p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: 36px; margin-bottom: 36px;" width="500px" src="binary-search-0.svg" /></p>
<p>We can then ask ourselves the question: could it be that <code>v</code> is right at the middle of <code>I</code>, at index</p>
<pre><code>mid = start + (end - start) / 2
    = 0 + (len(A) - 1 - 0) / 2
    = (len(a) - 1) / 2
</code></pre>
<p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: 36px; margin-bottom: 36px;" width="500px" src="binary-search.svg" /></p>
<p>If yes, we&rsquo;ve found our answer and the algorithm is over. If not, then we know that the answer must lie either in the interval</p>
<ul>
<li><code>I = [0, mid - 1]</code> if <code>A[mid] &gt; v</code> or</li>
<li><code>I = [mid + 1, end]</code> if <code>A[mid] &lt; v</code>.</li>
</ul>
<p>We can at this point recalculate <code>mid</code> over this new interval and repeat the process all over again. The algorithm is going to progressively halve the length of <code>I</code> until either we find a <code>mid</code> index such that <code>A[mid] = v</code> or until <code>start &gt; end</code>, signalling that <code>v</code> is not in the array.</p>
<p>As we&rsquo;re halving the size of the considered interval at each step, we&rsquo;re guaranteed to be executing, in the worst case scenario, roughly <code>O(lg n)</code> steps, hence the <code>O(lg n)</code> time complexity of the algorithm.</p>
<h2 id="implementation">Implementation</h2>
<p>There are two obvious ways of implementing the algorithm: either iteratively or recursively. Given that the iterative solution avoids stackoverflows and is generally faster without incurring into any obvious downsides, that&rsquo;s the one that will be shown:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
  
  <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="k">return</span> <span class="o">-</span><span class="n">1</span><span class="o">;</span> <span class="c1">// we couldn&#39;t find v in the array
</span><span class="c1"></span><span class="o">}</span>
</code></pre></div><h2 id="variants">Variants</h2>
<p>Now that we&rsquo;ve seen how to find a value <code>v</code> in a sorted array <code>A</code>, let&rsquo;s try to solve slightly different problems, all while still using binary search.</p>
<h3 id="find-first-element">Find First Element</h3>
<p>What happens when the given sorted array <code>A</code> contains duplicate elements? Our baseline algorithm will immediately return when finding <code>v</code>, so we&rsquo;re given no guarantees of which index will be returned. It may in certain cases be useful to know we&rsquo;re getting the first index, if multiple exist.</p>
<p>To do that, we make use of a new variable <code>candidate</code>, that will be used to store the smallest indice we&rsquo;ve found yet of an array element equal to <code>v</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
  <span class="kt">int</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
  
  <span class="k">while</span> <span class="o">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">A</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">candidate</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="k">return</span> <span class="n">candidate</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">?</span> <span class="o">-</span><span class="n">1</span> <span class="o">:</span> <span class="n">candidate</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><h3 id="count-number-of-occurrences">Count Number Of Occurrences</h3>
<p>And what about finding how many occurrences of a given <code>v</code> can we find in a sorted array? One possibility would be implementing two methods, one calculating the index of the first occurrence of <code>v</code> in <code>A</code> (<code>leftIdx</code>) and another one calculating the index of the last occurrence of <code>v</code> in <code>A</code> (<code>rightIdx</code>). The number of occurrences would then be <code>rightIdx - leftIdx + 1</code>.</p>
<p>And while that solution works, it also means some duplicated code.. something we&rsquo;d like to avoid.</p>
<p>A better alternative is to implement a single <code>binarySearch(A, v)</code> method that will calculate what&rsquo;s the index of the first index of <code>v</code>, if <code>v</code> exists, or what would the index be in case we&rsquo;d like to insert <code>v</code> into <code>A</code>. We can then use <code>leftIndex = binarySearch(A, v)</code> to find the index of the first element in the array, if it exists, and then calculate <code>rightIndex = binarySearch(A, v + 1)</code> to find the index of the next element, if it exists. The result should then be <code>rightIndex - leftIndex</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">countOccurrences</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="n">leftIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">leftIdx</span> <span class="o">==</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">||</span> <span class="n">A</span><span class="o">[</span><span class="n">leftIdx</span><span class="o">]</span> <span class="o">!=</span> <span class="n">v</span><span class="o">)</span>
    <span class="k">return</span> <span class="n">0</span><span class="o">;</span>

  <span class="kt">int</span> <span class="n">rightIdx</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">v</span><span class="o">);</span>

  <span class="k">return</span> <span class="n">rightIdx</span> <span class="o">-</span> <span class="n">leftIdx</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div><p>Do note we could alternatively have defined <code>binarySearch(A, v, start, end)</code>, such that the call to calculate the first index would go like</p>
<pre><code>leftIndex = binarySearch(A, v, 0, A.length - 1)
</code></pre>
<p>and for the right index</p>
<pre><code>rightIndex = binarySearch(A, v + 1, leftIndex + 1, end)
</code></pre>
<h3 id="building-a-balanced-binary-search-tree-out-of-a-sorted-array">Building a Balanced Binary Search Tree Out of a Sorted Array</h3>
<p>If we&rsquo;re given a sorted array, what&rsquo;s the quickest way of creating a balanced binary search tree out of it?</p>
<p>Well, as the diagram below exemplifies, the root node is right at the center of the interval that goes from the first to the last elements of the array. Its left subnode and right subnodes also sit at the middle of the intervals <code>[0, mid - 1]</code> and <code>[mid + 1, end]</code>, and so on:</p>
<p><img style="display: block; margin-left: auto; margin-right: auto; margin-top: 36px; margin-bottom: 36px;" width="800" src="bst-building2.svg" /></p>
<p>So a simple recursive implementation that always creates a node out of the current mid should suffice:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">createTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">createTree</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">0</span><span class="o">,</span> <span class="n">A</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">1</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="n">Node</span> <span class="nf">createTree</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">A</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="o">)</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    
  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="o">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">)</span> <span class="o">/</span> <span class="n">2</span><span class="o">;</span>
  
  <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span>
    <span class="n">A</span><span class="o">[</span><span class="n">mid</span><span class="o">],</span>
    <span class="n">createTree</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="n">1</span><span class="o">),</span>
    <span class="n">createTree</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="n">end</span><span class="o">)</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre></div><p>This problem can also be seen at <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Leetcode - Convert Sorted Array To Binary Search Tree</a>.</p>
<h1 id="problems">Problems</h1>
<p>Here I&rsquo;m listing some interesting applications of binary search to leetcode problems. For some of them binary search may come as the obvious technique to use, while for others, not so much.</p>
<h3 id="first-bad-version">First Bad Version</h3>
<p>Link: <a href="https://leetcode.com/problems/first-bad-version">First Bad Version</a></p>
<p>Binary search. If the version is bad, keep the current version as a candidate result but attempt to find a previous version that is also bad.</p>
<h3 id="search-a-2d-matrix">Search a 2D Matrix</h3>
<p>Link: <a href="https://leetcode.com/problems/search-a-2d-matrix/">Search a 2D Matrix</a></p>
<p>At first sight, we may be tempted to solve it with two <code>binarySearch()</code> methods: one that searches over rows and another one searching over columns. But we can avoid all of that if we instead think of this 2D array as a single 1D array, making use of the fact that we know that the last element of row <code>R</code> is always smaller than the first element of row <code>R + 1</code>. Then it all just turns into a matter of converting indexes from the 1D to the 2D array back and forth while binary searching.</p>
<h3 id="sqrtx">Sqrt(x)</h3>
<p>Link: <a href="https://leetcode.com/problems/sqrtx/">Sqrt(x)</a></p>
<p>There are for sure more efficient ways to calculate the square root of a number, but binary search can also help us here if we&rsquo;re don&rsquo;t know any better.</p>
<p>Gist of the algorithm: we know that the square root of a number <code>k</code> must be a number between <code>1</code> and <code>k</code>, so we can binary search over that interval, finding a result in <code>O(lg n)</code> time.</p>
<h3 id="minimum-number-of-days-to-make-m-bouquets">Minimum Number of Days to Make m Bouquets</h3>
<p>Link: <a href="https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets">Minimum Number of Days to Make m Bouquets</a></p>
<p>We want to guess what&rsquo;s the minimum number of days containing enough sequences of already blossomed flowers to create the needed amount of bouquets. Checking whether at a given day there are enough adjacent flowers to create all the needed bouquets can be calculated in <code>O(n)</code>, so we just need to binary search over the possible range of days (minimum and maximum days that a flower can blossom). The end solution will comfortably run in <code>O(n lg n)</code>.</p>
<h3 id="koko-eating-bananas">Koko Eating Bananas</h3>
<p>Link: <a href="https://leetcode.com/problems/koko-eating-bananas">Koko Eating Bananas</a>.</p>
<p>A problem that can be solved similarly to <code>Minimum Number of Days to Make M Bouquets</code>.</p>]]></content>
		</item>
		
	</channel>
</rss>
